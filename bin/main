#!/usr/bin/env ruby

#
#   In[]  =>  Process => Out[] (Console)
#
# In 1. interactive 2. file

# Interactive
#
# Char registration
#
# > char add john
# ===> +john
#
#
# 'ki ... ex)
#  >  ki john hooks up mary
#  ===> |ki| #john |hooks up| #mary
# 'so ...
# 'ten ...
# 'ke ...


# Show

# Individual-Based
#
# john  => |ki| hooks up mary
#          |so| go to school
#          |ten| fight with #enemy
#          |ke| win enemy

CHARACTER = "char"
ROOT = Dir.pwd

# id

def overwrite_id(id)
  f = File.open("#{ROOT}/id", "w")
  f.puts id
  f.close
end

def getRootDir()
  f = File.open("#{ROOT}/id", "r")
  id = f.each_line.to_a
  if (id.size == 0 || id[0].strip == "")
    abort "id file is blanc"
  end

  dir = "#{ROOT}/../data/#{id[0].chomp}/"
  if !Dir.exist? dir
    require 'fileutils'
    FileUtils::mkdir_p dir
  end
  dir
end

def get_file(file, op)
  file = "#{getRootDir}#{file.chomp}"
  guaranteeFileExistence file
  File.open(file, op)
end

def guaranteeFileExistence(file)
  if !File.exist? file
    tmp = File.new file, "w"
    tmp.close
  end
  file
end

def add(file, content)
  f = get_file file, "a"
  f.puts content
  f.close
end

def delete(file, content)
  f = get_file file, "r"
  new_file = Array.new
  f.each_line { |c|
    if c.chomp != content
      new_file.push c
    end
  }
  f.close
  f = get_file file, "w"
  new_file.each{ |c|
    f.puts c
  }
  f.close
end

def operate(input)
  if input.size < 3
    abort  "argument size is too short"
  end
  case input[1]
  when "add"
    add(input[0], input[2])
  when "delete"
    delete(input[0], input[2])
  end
end

def read_input(input)
  if input.size == 0
    abort "you need argument"
  end
  operate(input)
end

# -- test section --

# add character
read_input(["char", "add", "john"])
# delete character
read_input(["char", "delete", "john"])
overwrite_id "maxim"
overwrite_id "hawk"
read_input(["ki", "add", "john loves mary"])
