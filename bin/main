#!/usr/bin/env ruby

#
#   In[]  =>  Process => Out[] (Console)
#
# In 1. interactive 2. file

# Interactive
#
# Char registration
#
# > char add john
# ===> +john
#
#
# 'ki ... ex)
#  >  ki john hooks up mary
#  ===> |ki| #john |hooks up| #mary
# 'so ...
# 'ten ...
# 'ke ...


# Show

# Individual-Based
#
# john  => |ki| hooks up mary
#          |so| go to school
#          |ten| fight with #enemy
#          |ke| win enemy

CHARACTER = "char"
ROOT = Dir.pwd

# id, id_table

def getRootDir()
  f = File.open("#{ROOT}/id", "r")
  id = f.each_line.to_a
  if (id.size == 0 || id[0].strip == "")
    abort "id file is blanc"
  end
  # this gott a be path or somethin?
  dir = "#{ROOT}/../data/#{id[0].chomp}/"
  if !Dir.exist? dir
    require 'fileutils'
    FileUtils::mkdir_p dir
  end
  dir
end

def get_file(file, op)
  file = "#{getRootDir}#{file.chomp}"
  guaranteeFileExistence file
  File.open(file, op)
end

def guaranteeFileExistence(file)
  puts "--  #{file}  --"
  if !File.exist? file
    tmp = File.new file, "w"
    tmp.close
  end
  file
end

def add(file, content)
  f = get_file file, "a"
  f.puts content
  f.close
end

def delete(file, content)
  f = get_file file, "r"
  new_file = Array.new
  f.each_line { |c|
    if c.chomp != content
      new_file.push c
    end
  }
  f.close
  f = get_file file, "w"
  new_file.each{ |c|
    f.puts c
  }
  f.close
end

def operateChar(input)
  if input.size < 3
    abort  "argument size is too short"
  end
  case input[1]
  when "add"
    add(CHARACTER, input[2])
  when "delete"
    delete(CHARACTER, input[2])
  end
end

def read_input(input)
  if input.size == 0
    abort "you need argument"
  end
  case input[0]
  when "char"
    operateChar(input)
  end
end

# -- test section --

# add character
read_input(["char", "add", "john"])
# delete character
#read_input(["char", "delete", "john"])


